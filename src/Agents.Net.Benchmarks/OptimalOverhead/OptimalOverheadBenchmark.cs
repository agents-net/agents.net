using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using BenchmarkDotNet.Attributes;

namespace Agents.Net.Benchmarks.OptimalOverhead
{
    /// <summary>
    /// This benchmark tests the optimal - minimal - overhead which is generated by delegating the work to background workers.
    /// </summary>
    /// <remarks>
    ///   <para>
    ///     <strong>Use Case</strong>
    ///   </para>
    ///   <para>Running 1000 workloads sequentially with a <c>Thread.SpinWait(15)</c> workload.</para>
    ///   <para>
    ///     <strong>Scenarios</strong>
    ///   </para>
    ///   <list type="table">
    ///     <item>
    ///       <description>
    ///         <c>SingleThread</c>
    ///       </description>
    ///       <description>Comparision base line.</description>
    ///     </item>
    ///     <item>
    ///       <description>
    ///         <c>ThreadPool</c>
    ///       </description>
    ///       <description>Using <c>ThreadPool.QueueUserWorkItem(Work)</c> as background worker.</description>
    ///     </item>
    ///     <item>
    ///       <description>
    ///         <c>TaskRun</c>
    ///       </description>
    ///       <description>Using <c>Task.Run(Work)</c> as background worker.</description>
    ///     </item>
    ///   </list>
    /// </remarks>
    public class OptimalOverheadBenchmark
    {
        private const int Iterations = 1000;

        [Benchmark(Baseline = true)]
        public void SingleThread()
        {
            for (int i = 0; i < Iterations; i++)
            {
                Thread.SpinWait(15);
            }
        }

        [Benchmark]
        public void ThreadPool()
        {
            int remaining = Iterations;
            using ManualResetEventSlim resetEvent = new ManualResetEventSlim(false);
            System.Threading.ThreadPool.QueueUserWorkItem(Work);
            resetEvent.Wait();

            void Work(object state)
            {
                Thread.SpinWait(15);
                remaining--;
                if (remaining == 0)
                {
                    resetEvent.Set();
                }
                else
                {
                    System.Threading.ThreadPool.QueueUserWorkItem(Work);
                }
            }
        }

        [Benchmark]
        public void TaskRun()
        {
            int remaining = Iterations;
            using ManualResetEventSlim resetEvent = new ManualResetEventSlim(false);
            Task.Run(Work);
            resetEvent.Wait();

            void Work()
            {
                Thread.SpinWait(15);
                remaining--;
                if (remaining == 0)
                {
                    resetEvent.Set();
                }
                else
                {
                    Task.Run(Work);
                }
            }
        }
    }
}
